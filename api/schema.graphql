# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddAttributesGroupToRubricInput {
  attributesGroupId: ID!
  rubricId: ID!
}

input AddAttributeToGroupInput {
  groupId: ID!
  metric: ID
  name: [LangInput!]!
  options: ID
  positioningInTitle: [AttributePositioningInTitleInput!]
  variant: AttributeVariantEnum!
}

input AddOptionToGroupInput {
  color: String
  gender: GenderEnum
  groupId: ID!
  name: [LangInput!]!
  variants: [OptionVariantInput!]
}

input AddProductToRubricInput {
  productId: ID!
  rubricId: ID!
}

type AssetType {
  index: Int!
  url: String!
}

type Attribute {
  """list of options with products counter for catalogue filter"""
  filterOptions(filter: [String!]!): [AttributeFilterOption!]!
  id: ID!
  metric: Metric
  name: [LanguageType!]!
  nameString: String!
  options: OptionsGroup
  positioningInTitle: [AttributePositioningInTitle!]
  slug: String!
  variant: AttributeVariantEnum!
}

type AttributeFilterOption {
  counter: Int!
  option: Option!
}

type AttributePositioningInTitle {
  key: String!
  value: AttributePositionInTitleEnum!
}

input AttributePositioningInTitleInput {
  key: String!
  value: AttributePositionInTitleEnum!
}

type AttributePositioningOption {
  id: String!
  nameString: String!
}

"""
Instruction for positioning checked attribute values in catalogue title
"""
enum AttributePositionInTitleEnum {
  afterKeyword
  beforeKeyword
  begin
  end
  replaceKeyword
}

type AttributesGroup {
  attributes: [Attribute!]!
  id: ID!
  name: [LanguageType!]!
  nameString: String!
}

type AttributesGroupPayloadType {
  group: AttributesGroup
  message: String!
  success: Boolean!
}

type AttributeVariant {
  id: ID!
  nameString: String!
}

"""Attribute variant enum"""
enum AttributeVariantEnum {
  multipleSelect
  number
  select
  string
}

type CatalogueData {
  catalogueTitle: String!
  products: PaginatedProductsResponse!
  rubric: Rubric!
}

input CreateAttributesGroupInput {
  name: [LangInput!]!
}

input CreateMetricInput {
  name: [LangInput!]!
}

input CreateOptionsGroupInput {
  name: [LangInput!]!
}

input CreateProductInput {
  assets: [Upload!]!
  attributesGroups: [ProductAttributesGroupInput!]!
  cardName: [LangInput!]!
  description: [LangInput!]!
  name: [LangInput!]!
  price: Int!
  rubrics: [ID!]!
}

input CreateRubricInput {
  catalogueTitle: RubricCatalogueTitleInput!
  name: [LangInput!]!
  parent: ID
  variant: ID
}

input CreateRubricVariantInput {
  name: [LangInput!]!
}

input CreateUserInput {
  email: String!
  lastName: String
  name: String!
  phone: String!
  role: String
  secondName: String
}

input DeleteAttributeFromGroupInput {
  attributeId: ID!
  groupId: ID!
}

input DeleteAttributesGroupFromRubricInput {
  attributesGroupId: ID!
  rubricId: ID!
}

input DeleteOptionFromGroupInput {
  groupId: ID!
  optionId: ID!
}

input DeleteProductFromRubricInput {
  productId: ID!
  rubricId: ID!
}

"""List of gender enums"""
enum GenderEnum {
  he
  it
  she
}

type GenderOption {
  id: String!
  nameString: String!
}

input LangInput {
  key: String!
  value: String!
}

type LanguageType {
  key: String!
  value: String!
}

type Metric {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
}

type MetricPayloadType {
  message: String!
  metric: Metric
  success: Boolean!
}

type Mutation {
  addAttributesGroupToRubric(input: AddAttributesGroupToRubricInput!): RubricPayloadType!
  addAttributeToGroup(input: AddAttributeToGroupInput!): AttributesGroupPayloadType!
  addOptionToGroup(input: AddOptionToGroupInput!): OptionsGroupPayloadType!
  addProductToRubric(input: AddProductToRubricInput!): RubricPayloadType!
  createAttributesGroup(input: CreateAttributesGroupInput!): AttributesGroupPayloadType!
  createMetric(input: CreateMetricInput!): MetricPayloadType!
  createOptionsGroup(input: CreateOptionsGroupInput!): OptionsGroupPayloadType!
  createProduct(input: CreateProductInput!): ProductPayloadType!
  createRubric(input: CreateRubricInput!): RubricPayloadType!
  createRubricVariant(input: CreateRubricVariantInput!): RubricVariantPayloadType!
  createUser(input: CreateUserInput!): UserPayloadType!
  deleteAttributeFromGroup(input: DeleteAttributeFromGroupInput!): AttributesGroupPayloadType!
  deleteAttributesGroup(id: ID!): AttributesGroupPayloadType!
  deleteAttributesGroupFromRubric(input: DeleteAttributesGroupFromRubricInput!): RubricPayloadType!
  deleteMetric(id: ID!): MetricPayloadType!
  deleteOptionFromGroup(input: DeleteOptionFromGroupInput!): OptionsGroupPayloadType!
  deleteOptionsGroup(id: ID!): OptionsGroupPayloadType!
  deleteProduct(id: ID!): ProductPayloadType!
  deleteProductFromRubric(input: DeleteProductFromRubricInput!): RubricPayloadType!
  deleteRubric(id: ID!): RubricPayloadType!
  deleteRubricVariant(id: ID!): RubricVariantPayloadType!
  deleteUser(id: ID!): UserPayloadType!
  signIn(input: SignInInput!): UserPayloadType!
  signOut: UserPayloadType!
  signUp(input: SignUpInput!): UserPayloadType!
  updateAttributeInGroup(input: UpdateAttributeInGroupInput!): AttributesGroupPayloadType!
  updateAttributesGroup(input: UpdateAttributesGroupInput!): AttributesGroupPayloadType!
  updateAttributesGroupInRubric(input: UpdateAttributesGroupInRubricInput!): RubricPayloadType!
  updateMetric(input: UpdateMetricInput!): MetricPayloadType!
  updateOptionInGroup(input: UpdateOptionInGroupInput!): OptionsGroupPayloadType!
  updateOptionsGroup(input: UpdateOptionsGroupInput!): OptionsGroupPayloadType!
  updateProduct(input: UpdateProductInput!): ProductPayloadType!
  updateRubric(input: UpdateRubricInput!): RubricPayloadType!
  updateRubricVariant(input: UpdateRubricVariantInput!): RubricVariantPayloadType!
  updateUser(input: UpdateUserInput!): UserPayloadType!
}

type Option {
  color: String
  gender: GenderEnum
  id: ID!
  name: [LanguageType!]!
  nameString: String!
  slug: String!
  variants: [OptionVariant!]
}

type OptionsGroup {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
  options: [Option!]!
}

type OptionsGroupPayloadType {
  group: OptionsGroup
  message: String!
  success: Boolean!
}

type OptionVariant {
  key: GenderEnum!
  value: [LanguageType!]!
}

input OptionVariantInput {
  key: GenderEnum!
  value: [LangInput!]!
}

type PaginatedProductsResponse {
  activeProductsCount: Int
  docs: [Product!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PaginatedUsersResponse {
  docs: [User!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

"""Pagination sortDir enum"""
enum PaginateSortDirectionEnum {
  asc
  desc
}

type Product {
  active: Boolean!
  assets: [AssetType!]!
  attributesGroups: [ProductAttributesGroup!]!
  cardName: String!
  cities: [ProductCity!]!
  createdAt: Timestamp!
  description: String!
  id: ID!
  itemId: Int!
  mainImage: String!
  name: String!
  price: Int!
  rubrics: [ID!]!
  slug: String!
  updatedAt: Timestamp!
}

type ProductAttribute {
  """Attribute reference via attribute slug field"""
  key: String!
  node: Attribute!
  showInCard: Boolean!
  value: [String!]!
}

input ProductAttributeInput {
  """Attribute reference via attribute slug field"""
  key: String!
  node: ID!
  showInCard: Boolean!
  value: [String!]!
}

type ProductAttributesGroup {
  attributes: [ProductAttribute!]!
  node: AttributesGroup!
  showInCard: Boolean!
}

input ProductAttributesGroupInput {
  attributes: [ProductAttributeInput!]!
  node: ID!
  showInCard: Boolean!
}

type ProductCity {
  key: String!
  node: ProductNode!
}

type ProductNode {
  active: Boolean!
  assets: [AssetType!]!
  attributesGroups: [ProductAttributesGroup!]!
  cardName: [LanguageType!]!
  description: [LanguageType!]!
  name: [LanguageType!]!
  price: Int!
  rubrics: [ID!]!
  slug: String!
}

input ProductPaginateInput {
  countActiveProducts: Boolean
  limit: Int = 100
  noRubrics: Boolean
  notInRubric: ID
  page: Int = 1
  rubric: ID
  search: String
  sortBy: ProductSortByEnum = createdAt
  sortDir: PaginateSortDirectionEnum = desc
}

type ProductPayloadType {
  message: String!
  product: Product
  success: Boolean!
}

type ProductsCounters {
  activeProductsCount: Int!
  totalProductsCount: Int!
}

input ProductsCountersInput {
  noRubrics: Boolean
  notInRubric: ID
  rubric: ID
}

"""Product pagination sortBy enum"""
enum ProductSortByEnum {
  createdAt
  price
}

type Query {
  getAllAttributesGroups(
    """list of excluded groups id's"""
    exclude: [ID!]
  ): [AttributesGroup!]!
  getAllMetrics: [Metric!]
  getAllOptionsGroups: [OptionsGroup!]!
  getAllProducts(input: ProductPaginateInput): PaginatedProductsResponse!
  getAllRubricVariants: [RubricVariant!]
  getAllUsers(input: UserPaginateInput!): PaginatedUsersResponse!
  getAttribute(id: ID!): Attribute
  getAttributePositioningOptions: [AttributePositioningOption!]!
  getAttributesGroup(id: ID!): AttributesGroup
  getAttributeVariants: [AttributeVariant!]
  getCatalogueData(catalogueFilter: [String!]!, productsInput: ProductPaginateInput): CatalogueData
  getFeaturesAst(selectedRubrics: [ID!]!): [AttributesGroup!]!
  getGenderOptions: [GenderOption!]!
  getMetric(id: ID!): Metric
  getOption(id: ID!): Option
  getOptionsGroup(id: ID!): OptionsGroup
  getProduct(id: ID!): Product!
  getProductsCounters(input: ProductsCountersInput!): ProductsCounters!
  getRubric(id: ID!): Rubric!
  getRubricBySlug(slug: String!): Rubric!
  getRubricsTree(excluded: [ID!]): [Rubric!]!
  getRubricVariant(id: ID!): RubricVariant
  getUser(id: ID!): User
  me: User
}

type Rubric {
  active: Boolean!
  activeProductsCount: Int!
  attributesGroups: [RubricAttributesGroup!]!
  catalogueTitle: RubricCatalogueTitleField!
  children(excluded: [ID!]): [Rubric!]!
  cities: [RubricCity!]!
  filterAttributes: [Attribute!]!
  id: ID!
  level: Int!
  name: String!
  parent: Rubric
  products(input: RubricProductPaginateInput): PaginatedProductsResponse!
  slug: String!
  totalProductsCount: Int!
  variant: RubricVariant
}

type RubricAttributesGroup {
  id: ID!
  isOwner: Boolean!
  node: AttributesGroup!
  showInCatalogueFilter: [ID!]!
}

type RubricCatalogueTitle {
  defaultTitle: [LanguageType!]!
  gender: GenderEnum!
  keyword: [LanguageType!]!
  prefix: [LanguageType!]
}

type RubricCatalogueTitleField {
  defaultTitle: String!
  gender: GenderEnum!
  keyword: String!
  prefix: String
}

input RubricCatalogueTitleInput {
  defaultTitle: [LangInput!]!
  gender: GenderEnum!
  keyword: [LangInput!]!
  prefix: [LangInput!]
}

type RubricCity {
  key: String!
  node: RubricNode!
}

type RubricNode {
  active: Boolean
  attributesGroups: [RubricAttributesGroup!]!
  catalogueTitle: RubricCatalogueTitle!
  level: Int!
  name: [LanguageType!]!
  parent: Rubric
  slug: String!
  variant: RubricVariant
}

type RubricPayloadType {
  message: String!
  rubric: Rubric
  success: Boolean!
}

input RubricProductAttributesFilterInput {
  key: String!
  value: [String!]!
}

input RubricProductPaginateInput {
  active: Boolean
  attributes: [RubricProductAttributesFilterInput!]
  limit: Int = 100
  notInRubric: ID
  page: Int = 1
  search: String
  sortBy: ProductSortByEnum = createdAt
  sortDir: PaginateSortDirectionEnum = desc
}

type RubricVariant {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
}

type RubricVariantPayloadType {
  message: String!
  success: Boolean!
  variant: RubricVariant
}

input SignInInput {
  email: String!
  password: String!
}

input SignUpInput {
  email: String!
  lastName: String
  name: String!
  password: String!
  phone: String
  secondName: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

input UpdateAttributeInGroupInput {
  attributeId: ID!
  groupId: ID!
  metric: ID
  name: [LangInput!]!
  options: ID
  positioningInTitle: [AttributePositioningInTitleInput!]
  variant: AttributeVariantEnum!
}

input UpdateAttributesGroupInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateAttributesGroupInRubricInput {
  attributeId: ID!
  attributesGroupId: ID!
  rubricId: ID!
}

input UpdateMetricInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateOptionInGroupInput {
  color: String
  gender: GenderEnum
  groupId: ID!
  name: [LangInput!]!
  optionId: ID!
  variants: [OptionVariantInput!]
}

input UpdateOptionsGroupInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateProductInput {
  assets: [Upload!]!
  attributesGroups: [ProductAttributesGroupInput!]!
  cardName: [LangInput!]!
  description: [LangInput!]!
  id: ID!
  name: [LangInput!]!
  price: Int!
  rubrics: [ID!]!
}

input UpdateRubricInput {
  catalogueTitle: RubricCatalogueTitleInput!
  id: ID!
  name: [LangInput!]!
  parent: ID
  variant: ID
}

input UpdateRubricVariantInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateUserInput {
  email: String!
  id: ID!
  lastName: String
  name: String!
  phone: String!
  role: String!
  secondName: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  createdAt: Timestamp!
  email: String!
  fullName: String!
  id: ID!
  isAdmin: Boolean!
  isCustomer: Boolean!
  isManager: Boolean!
  itemId: Int!
  lastName: String
  name: String!
  phone: String!
  role: String!
  secondName: String
  shortName: String!
  updatedAt: Timestamp!
}

input UserPaginateInput {
  limit: Int = 100
  page: Int = 1
  search: String
  sortBy: UserSortByEnum = createdAt
  sortDir: PaginateSortDirectionEnum = desc
}

type UserPayloadType {
  message: String!
  success: Boolean!
  user: User
}

"""User pagination sortBy enum"""
enum UserSortByEnum {
  createdAt
  email
  lastName
  name
  phone
  role
  secondName
}
