# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddAttributesGroupToRubricInput {
  attributesGroupId: ID!
  rubricId: ID!
}

input AddAttributeToGroupInput {
  groupId: ID!
  metric: ID
  name: [TranslationInput!]!
  optionsGroup: ID
  positioningInTitle: [AttributePositioningInTitleInput!]
  variant: AttributeVariantEnum!
}

input AddCityToCountryInput {
  countryId: ID!
  name: [TranslationInput!]!
  slug: String!
}

input AddOptionToGroupInput {
  color: String
  gender: GenderEnum
  groupId: ID!
  icon: String
  name: [TranslationInput!]!
  variants: [OptionVariantInput!]
}

input AddProductToConnectionInput {
  addProductId: ID!
  connectionId: ID!
  productId: ID!
}

input AddProductToRubricInput {
  productId: ID!
  rubricId: ID!
}

input AddProductToShopInput {
  available: Int!
  price: Int!
  productId: ID!
  shopId: ID!
}

type Address {
  formattedAddress: String!
  formattedCoordinates: Coordinates!
  point: PointGeoJSON!
}

input AddressInput {
  formattedAddress: String!
  point: CoordinatesInput!
}

input AddShopToCompanyInput {
  address: AddressInput!
  assets: [Upload!]!
  companyId: ID!
  contacts: ContactsInput!
  logo: [Upload!]!
  nameString: String!
}

type Asset {
  index: Int!
  url: String!
}

type Attribute {
  id: ID!
  metric: Metric
  name: [Translation!]!
  nameString: String!
  optionsGroup: OptionsGroup
  positioningInTitle: [AttributePositioningInTitle!]
  priorities: [AttributeCityCounter!]!
  slug: String!
  variant: AttributeVariantEnum!
  views: [AttributeCityCounter!]!
}

type AttributeCityCounter {
  counter: Int
  key: String!
  rubricId: String!
}

type AttributePositioningInTitle {
  key: String!
  value: AttributePositionInTitleEnum!
}

input AttributePositioningInTitleInput {
  key: String!
  value: AttributePositionInTitleEnum!
}

type AttributePositioningOption {
  id: String!
  nameString: String!
}

"""
Instruction for positioning checked attribute values in catalogue title
"""
enum AttributePositionInTitleEnum {
  afterKeyword
  beforeKeyword
  begin
  end
  replaceKeyword
}

type AttributesGroup {
  attributes: [Attribute!]!
  id: ID!
  name: [Translation!]!
  nameString: String!
}

type AttributesGroupPayloadType {
  group: AttributesGroup
  message: String!
  success: Boolean!
}

type AttributeVariant {
  id: ID!
  nameString: String!
}

"""Attribute variant enum"""
enum AttributeVariantEnum {
  multipleSelect
  number
  select
  string
}

type AttributeViewOption {
  id: String!
  nameString: String!
}

type CatalogueData {
  catalogueTitle: String!
  products: PaginatedProductsResponse!
  rubric: Rubric!
}

type CatalogueSearchResult {
  products: [Product!]!
  rubrics: [Rubric!]!
}

type City {
  id: ID!
  name: [Translation!]!
  nameString: String!
  slug: String!
}

type CityCounter {
  counter: Int
  key: String!
}

input CityLangInput {
  key: String!
  value: [String!]!
}

"""Companies pagination sortBy enum"""
enum CompaniesSortByEnum {
  createdAt
}

type Company {
  contacts: Contacts!
  createdAt: DateTime!
  id: ID!
  itemId: Int!
  logo: Asset!
  nameString: String!
  owner: User!
  shops(input: ShopPaginateInput = {}): PaginatedShopsResponse!
  slug: String!
  staff: [User!]!
  updatedAt: DateTime!
}

input CompanyPaginateInput {
  limit: Int = 100
  page: Int = 1
  search: String
  sortBy: CompaniesSortByEnum = createdAt
  sortDir: SortDirectionEnum = desc
}

type CompanyPayloadtype {
  company: Company
  message: String!
  success: Boolean!
}

type Config {
  """Accepted formats for asset config."""
  acceptedFormats: [String!]!
  cities: [ConfigCity!]!
  description: String!
  id: ID!

  """Set to true if config is able to hold multiple values."""
  multi: Boolean!
  nameString: String!
  order: Float!
  slug: String!

  """Returns current value of current city."""
  value: [String!]!
  variant: ConfigVariantEnum!
}

type ConfigCity {
  city: City!
  key: String!
  translations: [ConfigLanguage!]!
}

input ConfigCityInput {
  key: String!
  translations: [CityLangInput!]!
}

type ConfigLanguage {
  key: String!
  value: [String!]!
}

type ConfigPayloadType {
  configs: [Config!]!
  message: String!
  success: Boolean!
}

"""Config variant enum"""
enum ConfigVariantEnum {
  asset
  email
  number
  string
  tel
}

type Contacts {
  emails: [String!]!
  formattedPhones: [FormattedPhone!]!
  phones: [String!]!
}

input ContactsInput {
  emails: [String!]!
  phones: [String!]!
}

type Coordinates {
  lat: Float!
  lng: Float!
}

input CoordinatesInput {
  lat: Float!
  lng: Float!
}

type Country {
  cities: [City!]!
  currency: String!
  id: ID!
  nameString: String!
}

type CountryPayloadType {
  country: Country
  message: String!
  success: Boolean!
}

input CreateAttributesGroupInput {
  name: [TranslationInput!]!
}

input CreateCompanyInput {
  contacts: ContactsInput!
  logo: [Upload!]!
  nameString: String!
  owner: ID!
  staff: [ID!]!
}

input CreateCountryInput {
  currency: String!
  nameString: String!
}

input CreateCurrencyInput {
  nameString: String!
}

input CreateLanguageInput {
  key: String!
  name: String!
  nativeName: String!
}

input CreateMetricInput {
  name: [TranslationInput!]!
}

input CreateOptionsGroupInput {
  name: [TranslationInput!]!
  variant: OptionsGroupVariantEnum
}

input CreateProductConnectionInput {
  attributeId: ID!
  attributesGroupId: ID!
  productId: ID!
}

input CreateProductInput {
  assets: [Upload!]!
  attributesGroups: [ProductAttributesGroupInput!]!
  cardName: [TranslationInput!]!
  description: [TranslationInput!]!
  name: [TranslationInput!]!
  price: Int!
  rubrics: [ID!]!
}

input CreateRoleInput {
  description: String!
  isStuff: Boolean!
  name: [TranslationInput!]!
}

input CreateRubricInput {
  catalogueTitle: RubricCatalogueTitleInput!
  name: [TranslationInput!]!
  parent: ID
  variant: ID!
}

input CreateRubricVariantInput {
  name: [TranslationInput!]!
}

input CreateUserInput {
  email: String!
  lastName: String
  name: String!
  phone: String!
  role: ID!
  secondName: String
}

type Currency {
  id: ID!
  nameString: String!
}

type CurrencyPayloadType {
  currency: Currency
  message: String!
  success: Boolean!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DeleteAttributeFromGroupInput {
  attributeId: ID!
  groupId: ID!
}

input DeleteAttributesGroupFromRubricInput {
  attributesGroupId: ID!
  rubricId: ID!
}

input DeleteCityFromCountryInput {
  cityId: ID!
  countryId: ID!
}

input DeleteOptionFromGroupInput {
  groupId: ID!
  optionId: ID!
}

input DeleteProductFromConnectionInput {
  connectionId: ID!
  deleteProductId: ID!
  productId: ID!
}

input DeleteProductFromRubricInput {
  productId: ID!
  rubricId: ID!
}

input DeleteProductFromShopInput {
  productId: ID!
  shopId: ID!
}

input DeleteShopFromCompanyInput {
  companyId: ID!
  shopId: ID!
}

type FormattedPhone {
  raw: String!
  readable: String!
}

"""List of gender enums"""
enum GenderEnum {
  he
  it
  she
}

type GenderOption {
  id: String!
  nameString: String!
}

input GetProductShopsInput {
  productId: ID!
  sortBy: String!
  sortDir: SortDirectionEnum!
}

type IconOption {
  icon: String!
  id: String!
  nameString: String!
}

type ISOLanguage {
  id: String!
  nameString: String!
  nativeName: String!
}

type Language {
  id: ID!
  isDefault: Boolean!
  key: String!
  name: String!
  nativeName: String!
}

type LanguagePayloadType {
  language: Language
  message: String!
  success: Boolean!
}

type Message {
  id: ID!
  key: String!
  message: [Translation!]!
}

type Metric {
  id: ID!
  name: [Translation!]!
  nameString: String!
}

type MetricPayloadType {
  message: String!
  metric: Metric
  success: Boolean!
}

type Mutation {
  addAttributesGroupToRubric(input: AddAttributesGroupToRubricInput!): RubricPayloadType!
  addAttributeToGroup(input: AddAttributeToGroupInput!): AttributesGroupPayloadType!
  addCityToCountry(input: AddCityToCountryInput!): CountryPayloadType!
  addOptionToGroup(input: AddOptionToGroupInput!): OptionsGroupPayloadType!
  addProductToConnection(input: AddProductToConnectionInput!): ProductPayloadType!
  addProductToRubric(input: AddProductToRubricInput!): RubricPayloadType!
  addProductToShop(input: AddProductToShopInput!): ShopPayloadType!
  addShopToCompany(input: AddShopToCompanyInput!): CompanyPayloadtype!
  createAttributesGroup(input: CreateAttributesGroupInput!): AttributesGroupPayloadType!
  createCompany(input: CreateCompanyInput!): CompanyPayloadtype!
  createCountry(input: CreateCountryInput!): CountryPayloadType!
  createCurrency(input: CreateCurrencyInput!): CurrencyPayloadType!
  createLanguage(input: CreateLanguageInput!): LanguagePayloadType!
  createMetric(input: CreateMetricInput!): MetricPayloadType!
  createOptionsGroup(input: CreateOptionsGroupInput!): OptionsGroupPayloadType!
  createProduct(input: CreateProductInput!): ProductPayloadType!
  createProductConnection(input: CreateProductConnectionInput!): ProductPayloadType!
  createRole(input: CreateRoleInput!): RolePayloadType!
  createRubric(input: CreateRubricInput!): RubricPayloadType!
  createRubricVariant(input: CreateRubricVariantInput!): RubricVariantPayloadType!
  createUser(input: CreateUserInput!): UserPayloadType!
  deleteAttributeFromGroup(input: DeleteAttributeFromGroupInput!): AttributesGroupPayloadType!
  deleteAttributesGroup(id: ID!): AttributesGroupPayloadType!
  deleteAttributesGroupFromRubric(input: DeleteAttributesGroupFromRubricInput!): RubricPayloadType!
  deleteCityFromCountry(input: DeleteCityFromCountryInput!): CountryPayloadType!
  deleteCompany(id: ID!): CompanyPayloadtype!
  deleteCountry(id: ID!): CountryPayloadType!
  deleteCurrency(id: ID!): CurrencyPayloadType!
  deleteLanguage(id: ID!): LanguagePayloadType!
  deleteMetric(id: ID!): MetricPayloadType!
  deleteOptionFromGroup(input: DeleteOptionFromGroupInput!): OptionsGroupPayloadType!
  deleteOptionsGroup(id: ID!): OptionsGroupPayloadType!
  deleteProduct(id: ID!): ProductPayloadType!
  deleteProductFromConnection(input: DeleteProductFromConnectionInput!): ProductPayloadType!
  deleteProductFromRubric(input: DeleteProductFromRubricInput!): RubricPayloadType!
  deleteProductFromShop(input: DeleteProductFromShopInput!): ShopPayloadType!
  deleteRole(id: ID!): RolePayloadType!
  deleteRubric(id: ID!): RubricPayloadType!
  deleteRubricVariant(id: ID!): RubricVariantPayloadType!
  deleteShopFromCompany(input: DeleteShopFromCompanyInput!): CompanyPayloadtype!
  deleteUser(id: ID!): UserPayloadType!
  setLanguageAsDefault(id: ID!): LanguagePayloadType!
  setRoleAllowedNavItem(input: SetRoleAllowedNavItemInput!): RolePayloadType!
  setRoleOperationCustomFilter(input: SetRoleOperationCustomFilterInput!): RolePayloadType!
  setRoleOperationPermission(input: SetRoleOperationPermissionInput!): RolePayloadType!
  setRoleRuleRestrictedField(input: SetRoleRuleRestrictedFieldInput!): RolePayloadType!
  signIn(input: SignInInput!): UserPayloadType!
  signOut: UserPayloadType!
  signUp(input: SignUpInput!): UserPayloadType!
  updateAssetConfig(input: UpdateAssetConfigInput!): ConfigPayloadType!
  updateAttributeInGroup(input: UpdateAttributeInGroupInput!): AttributesGroupPayloadType!
  updateAttributesGroup(input: UpdateAttributesGroupInput!): AttributesGroupPayloadType!
  updateAttributesGroupInRubric(input: UpdateAttributesGroupInRubricInput!): RubricPayloadType!
  updateCityInCountry(input: UpdateCityInCountryInput!): CountryPayloadType!
  updateCompany(input: UpdateCompanyInput!): CompanyPayloadtype!
  updateConfig(input: UpdateConfigInput!): ConfigPayloadType!
  updateConfigs(input: [UpdateConfigInput!]!): ConfigPayloadType!
  updateCountry(input: UpdateCountryInput!): CountryPayloadType!
  updateCurrency(input: UpdateCurrencyInput!): CurrencyPayloadType!
  updateLanguage(input: UpdateLanguageInput!): LanguagePayloadType!
  updateMetric(input: UpdateMetricInput!): MetricPayloadType!
  updateMyPassword(input: UpdateMyPasswordInput!): UserPayloadType!
  updateMyProfile(input: UpdateMyProfileInput!): UserPayloadType!
  updateOptionInGroup(input: UpdateOptionInGroupInput!): OptionsGroupPayloadType!
  updateOptionsGroup(input: UpdateOptionsGroupInput!): OptionsGroupPayloadType!
  updateProduct(input: UpdateProductInput!): ProductPayloadType!
  updateRole(input: UpdateRoleInput!): RolePayloadType!
  updateRubric(input: UpdateRubricInput!): RubricPayloadType!
  updateRubricVariant(input: UpdateRubricVariantInput!): RubricVariantPayloadType!
  updateShop(input: UpdateShopInput!): ShopPayloadType!
  updateShopInCompany(input: UpdateShopInCompanyInput!): CompanyPayloadtype!
  updateShopProduct(input: UpdateShopProductInput!): ShopProductPayloadType!
  updateUser(input: UpdateUserInput!): UserPayloadType!
}

type NavItem {
  children: [NavItem!]
  icon: String
  id: String!
  name: [Translation!]!
  nameString: String!
  navGroup: String!
  order: Int!
  parent: NavItem
  path: String
}

type Option {
  color: String
  filterNameString: String!
  gender: GenderEnum
  icon: String
  id: ID!
  name: [Translation!]!
  nameString: String!
  priorities: [OptionCityCounter!]!
  slug: String!
  variants: [OptionVariant!]
  views: [OptionCityCounter!]!
}

type OptionCityCounter {
  attributeId: String!
  counter: Int
  key: String!
  rubricId: String!
}

type OptionsGroup {
  id: ID!
  name: [Translation!]!
  nameString: String!
  options: [Option!]!
  variant: OptionsGroupVariantEnum!
}

type OptionsGroupPayloadType {
  group: OptionsGroup
  message: String!
  success: Boolean!
}

"""Attribute variant enum"""
enum OptionsGroupVariantEnum {
  color
  icon
  text
}

type OptionsGroupVariantOption {
  id: String!
  nameString: String!
}

type OptionVariant {
  key: GenderEnum!
  value: [Translation!]!
}

input OptionVariantInput {
  key: GenderEnum!
  value: [TranslationInput!]!
}

type PaginatedCompaniesResponse {
  docs: [Company!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PaginatedProductsResponse {
  activeProductsCount: Int
  docs: [Product!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PaginatedShopProductsResponse {
  docs: [ShopProduct!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PaginatedShopsResponse {
  docs: [Shop!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PaginatedUsersResponse {
  docs: [User!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PointGeoJSON {
  """
  Coordinates that specifies the object’s coordinates. If specifying latitude and longitude coordinates, list the longitude first and then latitude.
  """
  coordinates: [Float!]!

  """Field that specifies the GeoJSON object type."""
  type: String!
}

type Product {
  active: Boolean!
  assets: [Asset!]!
  attributesGroups: [ProductAttributesGroup!]!
  cardConnections: [ProductCardConnection!]!
  cardFeatures: ProductCardFeatures!
  cardName: [Translation!]!
  cardNameString: String!
  cardPrices: ProductCardPrices!
  connections: [ProductConnection!]!
  createdAt: DateTime!
  description: [Translation!]!
  descriptionString: String!
  id: ID!
  itemId: Int!
  mainImage: String!
  name: [Translation!]!
  nameString: String!
  price: Int!
  priorities: [CityCounter!]!
  rubrics: [ID!]!
  shops(input: ProductShopsInput = {sortBy: "price", sortDir: asc}): [ProductShop!]!
  shopsCount: Int!
  slug: String!
  updatedAt: DateTime!
  views: [CityCounter!]!
}

type ProductAttribute {
  """Attribute reference via attribute slug field"""
  key: String!
  node: Attribute!
  readableOptions: [Option!]!
  readableValue: [String!]!
  showInCard: Boolean!
  value: [String!]!
  viewVariant: ProductAttributeViewVariantEnum!
}

input ProductAttributeInput {
  """Attribute reference via attribute slug field"""
  key: String!
  node: ID!
  showInCard: Boolean!
  value: [String!]!
  viewVariant: ProductAttributeViewVariantEnum
}

type ProductAttributesGroup {
  attributes: [ProductAttribute!]!
  node: AttributesGroup!
  showInCard: Boolean!
}

input ProductAttributesGroupInput {
  attributes: [ProductAttributeInput!]!
  node: ID!
  showInCard: Boolean!
}

"""Product attribute view variant enum"""
enum ProductAttributeViewVariantEnum {
  icon
  list
  outerRating
  tag
  text
}

type ProductCardConnection {
  """ID of connection"""
  id: ID!

  """Name of attribute used for connection"""
  nameString: String!
  products: [ProductCardConnectionItem!]!
}

type ProductCardConnectionItem {
  """ID of product"""
  id: ID!
  isCurrent: Boolean!
  product: Product!

  """Value of selected option for current product in connection"""
  value: String!
}

type ProductCardFeatures {
  iconFeatures: [ProductAttribute!]!
  listFeatures: [ProductAttribute!]!
  ratingFeatures: [ProductAttribute!]!
  tagFeatures: [ProductAttribute!]!
  textFeatures: [ProductAttribute!]!
}

type ProductCardPrices {
  max: String!
  min: String!
}

type ProductConnection {
  attribute: Attribute!
  attributeId: String!
  attributesGroupId: String!
  id: ID!
  products(
    """Shows only active products."""
    activeOnly: Boolean = false
  ): [ProductConnectionItem!]!
  productsIds: [String!]!
}

type ProductConnectionItem {
  node: Product!

  """Returns name of selected attribute value"""
  optionName: String!

  """
  Returns first value only because this attribute has to be Select variant
  """
  value: String!
}

input ProductPaginateInput {
  countActiveProducts: Boolean
  excludedProductsIds: [ID!]
  limit: Int = 100
  noRubrics: Boolean
  notInRubric: ID
  page: Int = 1
  rubric: ID
  search: String
  sortBy: ProductSortByEnum = priority
  sortDir: SortDirectionEnum = desc
}

type ProductPayloadType {
  message: String!
  product: Product
  success: Boolean!
}

type ProductsCounters {
  activeProductsCount: Int!
  totalProductsCount: Int!
}

input ProductsCountersInput {
  excludedProductsIds: [ID!]
  noRubrics: Boolean
  notInRubric: ID
  rubric: ID
}

type ProductShop {
  available: Int!
  createdAt: DateTime!
  discountedPercent: Int
  formattedOldPrice: String
  formattedPrice: String!
  id: ID!
  itemId: Int!
  node: Shop!
  oldPrices: [ShopProductOldPrice!]!
  price: Float!
  product: Product!
  shop: Shop!
  updatedAt: DateTime!
}

input ProductShopsInput {
  sortBy: String = "price"
  sortDir: SortDirectionEnum = asc
}

"""Product pagination sortBy enum"""
enum ProductSortByEnum {
  createdAt
  price
  priority
}

type Query {
  getAllAppNavItems: [NavItem!]!
  getAllAttributesGroups(
    """list of excluded groups id's"""
    exclude: [ID!] = []
  ): [AttributesGroup!]!
  getAllCities: [City!]!
  getAllCompanies(input: CompanyPaginateInput = {}): PaginatedCompaniesResponse!
  getAllConfigs: [Config!]!
  getAllCountries: [Country!]!
  getAllCurrencies: [Currency!]!
  getAllLanguages: [Language!]
  getAllMetrics: [Metric!]
  getAllOptionsGroups: [OptionsGroup!]!
  getAllProducts(input: ProductPaginateInput = {}): PaginatedProductsResponse!
  getAllRoles: [Role!]!
  getAllRubricVariants: [RubricVariant!]
  getAllShops(input: ShopPaginateInput = {}): PaginatedShopsResponse!
  getAllUsers(input: UserPaginateInput = {}): PaginatedUsersResponse!
  getAttribute(id: ID!): Attribute!
  getAttributePositioningOptions: [AttributePositioningOption!]!
  getAttributesGroup(id: ID!): AttributesGroup
  getAttributeVariantsOptions: [AttributeVariant!]
  getAttributeViewVariantsOptions: [AttributeViewOption!]!
  getCatalogueData(catalogueFilter: [String!]!, productsInput: ProductPaginateInput): CatalogueData
  getCatalogueSearchResult(search: String!): CatalogueSearchResult!
  getCatalogueSearchTopItems: CatalogueSearchResult!
  getCity(id: ID!): City!
  getCityBySlug(slug: String!): City!
  getClientLanguage: String!
  getCompany(id: ID!): Company!
  getConfigBySlug(slug: String!): Config!
  getConfigValueBySlug(slug: String!): [String!]!
  getCountry(id: ID!): Country!
  getCurrency(id: ID!): Currency!
  getEntityFields(entity: String!): [String!]!
  getFeaturesAst(selectedRubrics: [ID!]!): [AttributesGroup!]!
  getGenderOptions: [GenderOption!]!
  getIconsOptions: [IconOption!]!
  getISOLanguagesOptions: [ISOLanguage!]!
  getLanguage(id: ID!): Language!
  getMessage(key: String!): Message!
  getMessagesByKeys(keys: [String!]!): [Message!]!
  getMetric(id: ID!): Metric
  getOption(id: ID!): Option!
  getOptionsGroup(id: ID!): OptionsGroup
  getOptionsGroupVariantsOptions: [OptionsGroupVariantOption!]!
  getProduct(id: ID!): Product!
  getProductBySlug(slug: String!): Product!
  getProductCard(slug: String!): Product!
  getProductsCounters(input: ProductsCountersInput = {}): ProductsCounters!
  getProductShops(input: GetProductShopsInput!): [ProductShop!]!
  getRole(id: ID!): Role!
  getRubric(id: ID!): Rubric!
  getRubricBySlug(slug: String!): Rubric!
  getRubricsTree(excluded: [ID!] = []): [Rubric!]!
  getRubricVariant(id: ID!): RubricVariant!
  getSessionCurrency: String!
  getSessionRole: Role!
  getShop(id: ID!): Shop!
  getUser(id: ID!): User
  getValidationMessages: [Message!]!
  me: User
}

type Role {
  allowedAppNavigation: [ID!]!
  appNavigation: [NavItem!]!
  description: String!
  id: String!
  isStuff: Boolean!
  name: [Translation!]!
  nameString: String!
  rules: [RoleRule!]!
  slug: String!
}

type RolePayloadType {
  message: String!
  role: Role
  success: Boolean!
}

type RoleRule {
  entity: String!
  id: ID!
  nameString: String!
  operations: [RoleRuleOperation!]!
  restrictedFields: [String!]!
  roleId: ID!
}

type RoleRuleOperation {
  allow: Boolean!
  customFilter: String!
  id: ID!
  operationType: RoleRuleOperationTypeEnum!
  order: Int!
}

"""Role rule operation type enum"""
enum RoleRuleOperationTypeEnum {
  create
  delete
  read
  update
}

type Rubric {
  active: Boolean
  activeProductsCount(input: ProductsCountersInput = {}): Int!
  attributesGroups: [RubricAttributesGroup!]!
  catalogueTitle: RubricCatalogueTitle!
  catalogueTitleString: RubricCatalogueTitleField!
  children(excluded: [ID!] = []): [Rubric!]!
  filterAttributes: [RubricFilterAttribute!]!
  id: ID!
  level: Int!
  name: [Translation!]!
  nameString: String!
  parent: Rubric
  priorities: [CityCounter!]!
  priority: Int
  products(input: RubricProductPaginateInput = {}): PaginatedProductsResponse!
  slug: String!
  totalProductsCount(input: ProductsCountersInput = {}): Int!
  variant: RubricVariant!
  views: [CityCounter!]!
}

type RubricAttributesGroup {
  id: ID!
  isOwner: Boolean!
  node: AttributesGroup!
  showInCatalogueFilter: [ID!]!
}

type RubricCatalogueTitle {
  defaultTitle: [Translation!]!
  gender: GenderEnum!
  keyword: [Translation!]!
  prefix: [Translation!]
}

type RubricCatalogueTitleField {
  defaultTitle: String!
  gender: GenderEnum!
  keyword: String!
  prefix: String
}

input RubricCatalogueTitleInput {
  defaultTitle: [TranslationInput!]!
  gender: GenderEnum!
  keyword: [TranslationInput!]!
  prefix: [TranslationInput!]
}

type RubricFilterAttribute {
  id: ID!
  node: Attribute!
  options: [RubricFilterAttributeOption!]!
}

type RubricFilterAttributeOption {
  color: String
  counter: Int!
  filterNameString: String!
  gender: GenderEnum
  icon: String
  id: ID!
  name: [Translation!]!
  nameString: String!
  priorities: [OptionCityCounter!]!
  slug: String!
  variants: [OptionVariant!]
  views: [OptionCityCounter!]!
}

type RubricPayloadType {
  message: String!
  rubric: Rubric
  success: Boolean!
}

input RubricProductAttributesFilterInput {
  key: String!
  value: [String!]!
}

input RubricProductPaginateInput {
  active: Boolean
  attributes: [RubricProductAttributesFilterInput!]
  excludedProductsIds: [ID!]
  limit: Int = 100
  notInRubric: ID
  page: Int = 1
  search: String
  sortBy: ProductSortByEnum = createdAt
  sortDir: SortDirectionEnum = desc
}

type RubricVariant {
  id: ID!
  name: [Translation!]!
  nameString: String!
}

type RubricVariantPayloadType {
  message: String!
  success: Boolean!
  variant: RubricVariant
}

input SetRoleAllowedNavItemInput {
  navItemId: ID!
  roleId: ID!
}

input SetRoleOperationCustomFilterInput {
  customFilter: String!
  operationId: ID!
  roleId: ID!
}

input SetRoleOperationPermissionInput {
  allow: Boolean!
  operationId: ID!
  roleId: ID!
}

input SetRoleRuleRestrictedFieldInput {
  restrictedField: String!
  roleId: ID!
  ruleId: ID!
}

type Shop {
  address: Address!
  assets: [Asset!]!
  company: Company!
  contacts: Contacts!
  createdAt: DateTime!
  id: ID!
  itemId: Int!
  logo: Asset!
  nameString: String!
  products(input: ShopProductPaginateInput = {}): PaginatedShopProductsResponse!
  productsCount: Int!
  slug: String!
  updatedAt: DateTime!
}

input ShopPaginateInput {
  limit: Int = 100
  page: Int = 1
  search: String
  sortBy: ShopsSortByEnum = createdAt
  sortDir: SortDirectionEnum = desc
}

type ShopPayloadType {
  message: String!
  shop: Shop
  success: Boolean!
}

type ShopProduct {
  available: Int!
  createdAt: DateTime!
  id: ID!
  itemId: Int!
  oldPrices: [ShopProductOldPrice!]!
  price: Float!
  product: Product!
  shop: Shop!
  updatedAt: DateTime!
}

"""List of all old prices for shop product with dates of creation."""
type ShopProductOldPrice {
  createdAt: DateTime!
  id: ID!
  price: Float!
  updatedAt: DateTime!
}

input ShopProductPaginateInput {
  limit: Int = 100
  page: Int = 1
  search: String
  sortBy: ShopProductSortByEnum = createdAt
  sortDir: SortDirectionEnum = desc
}

type ShopProductPayloadType {
  message: String!
  product: ShopProduct
  success: Boolean!
}

"""Shop product pagination sortBy enum"""
enum ShopProductSortByEnum {
  createdAt
  price
}

"""Shops pagination sortBy enum"""
enum ShopsSortByEnum {
  company
  createdAt
}

input SignInInput {
  email: String!
  password: String!
}

input SignUpInput {
  email: String!
  lastName: String
  name: String!
  password: String!
  phone: String
  secondName: String
}

"""sortDir enum"""
enum SortDirectionEnum {
  asc
  desc
}

type Translation {
  key: String!
  value: String!
}

input TranslationInput {
  key: String!
  value: String!
}

input UpdateAssetConfigInput {
  id: ID!
  value: [Upload!]!
}

input UpdateAttributeInGroupInput {
  attributeId: ID!
  groupId: ID!
  metric: ID
  name: [TranslationInput!]!
  optionsGroup: ID
  positioningInTitle: [AttributePositioningInTitleInput!]
  variant: AttributeVariantEnum!
}

input UpdateAttributesGroupInput {
  id: ID!
  name: [TranslationInput!]!
}

input UpdateAttributesGroupInRubricInput {
  attributeId: ID!
  attributesGroupId: ID!
  rubricId: ID!
}

input UpdateCityInCountryInput {
  cityId: ID!
  countryId: ID!
  name: [TranslationInput!]!
  slug: String!
}

input UpdateCompanyInput {
  contacts: ContactsInput!
  id: ID!
  logo: [Upload!]!
  nameString: String!
  owner: ID!
  staff: [ID!]!
}

input UpdateConfigInput {
  cities: [ConfigCityInput!]!
  id: ID!
}

input UpdateCountryInput {
  currency: String!
  id: ID!
  nameString: String!
}

input UpdateCurrencyInput {
  id: ID!
  nameString: String!
}

input UpdateLanguageInput {
  id: ID!
  key: String!
  name: String!
  nativeName: String!
}

input UpdateMetricInput {
  id: ID!
  name: [TranslationInput!]!
}

input UpdateMyPasswordInput {
  id: ID!
  newPassword: String!
  newPasswordB: String!
  oldPassword: String!
}

input UpdateMyProfileInput {
  email: String!
  id: ID!
  lastName: String
  name: String!
  phone: String!
  secondName: String
}

input UpdateOptionInGroupInput {
  color: String
  gender: GenderEnum
  groupId: ID!
  icon: String
  name: [TranslationInput!]!
  optionId: ID!
  variants: [OptionVariantInput!]
}

input UpdateOptionsGroupInput {
  id: ID!
  name: [TranslationInput!]!
  variant: OptionsGroupVariantEnum
}

input UpdateProductInput {
  active: Boolean!
  assets: [Upload!]!
  attributesGroups: [ProductAttributesGroupInput!]!
  cardName: [TranslationInput!]!
  description: [TranslationInput!]!
  id: ID!
  name: [TranslationInput!]!
  price: Int!
  rubrics: [ID!]!
}

input UpdateRoleInput {
  description: String!
  id: ID!
  isStuff: Boolean!
  name: [TranslationInput!]!
}

input UpdateRubricInput {
  catalogueTitle: RubricCatalogueTitleInput!
  id: ID!
  name: [TranslationInput!]!
  parent: ID
  variant: ID!
}

input UpdateRubricVariantInput {
  id: ID!
  name: [TranslationInput!]!
}

input UpdateShopInCompanyInput {
  address: AddressInput!
  assets: [Upload!]!
  companyId: ID!
  contacts: ContactsInput!
  logo: [Upload!]!
  nameString: String!
  shopId: ID!
}

input UpdateShopInput {
  address: AddressInput!
  assets: [Upload!]!
  contacts: ContactsInput!
  logo: [Upload!]!
  nameString: String!
  shopId: ID!
}

input UpdateShopProductInput {
  available: Int!
  price: Int!
  productId: ID!
}

input UpdateUserInput {
  email: String!
  id: ID!
  lastName: String
  name: String!
  phone: String!
  role: ID!
  secondName: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  createdAt: DateTime!
  email: String!
  formattedPhone: FormattedPhone!
  fullName: String!
  id: ID!
  itemId: Int!
  lastName: String
  name: String!
  phone: String!
  role: Role!
  secondName: String
  shortName: String!
  updatedAt: DateTime!
}

input UserPaginateInput {
  limit: Int = 100
  page: Int = 1
  search: String
  sortBy: UserSortByEnum = createdAt
  sortDir: SortDirectionEnum = desc
}

type UserPayloadType {
  message: String!
  success: Boolean!
  user: User
}

"""User pagination sortBy enum"""
enum UserSortByEnum {
  createdAt
  email
  lastName
  name
  phone
  role
  secondName
}
