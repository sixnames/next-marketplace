# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddAttributesGroupToRubricInput {
  attributesGroupId: ID!
  rubricId: ID!
}

input AddAttributeToGroupInput {
  groupId: ID!
  metric: ID
  name: [LangInput!]!
  options: ID
  positioningInTitle: [AttributePositioningInTitleInput!]
  variant: AttributeVariantEnum!
}

input AddCityToCountryInput {
  countryId: ID!
  name: [LangInput!]!
  slug: String!
}

input AddOptionToGroupInput {
  color: String
  gender: GenderEnum
  groupId: ID!
  name: [LangInput!]!
  variants: [OptionVariantInput!]
}

input AddProductToConnectionInput {
  addProductId: ID!
  connectionId: ID!
  productId: ID!
}

input AddProductToRubricInput {
  productId: ID!
  rubricId: ID!
}

type AssetType {
  index: Int!
  url: String!
}

type Attribute {
  id: ID!
  metric: Metric
  name: [LanguageType!]!
  nameString: String!
  options: OptionsGroup
  positioningInTitle: [AttributePositioningInTitle!]
  priorities: [AttributeCityCounter!]!
  slug: String!
  variant: AttributeVariantEnum!
  views: [AttributeCityCounter!]!
}

type AttributeCityCounter {
  counter: Int
  key: String!
  rubricId: String!
}

type AttributePositioningInTitle {
  key: String!
  value: AttributePositionInTitleEnum!
}

input AttributePositioningInTitleInput {
  key: String!
  value: AttributePositionInTitleEnum!
}

type AttributePositioningOption {
  id: String!
  nameString: String!
}

"""
Instruction for positioning checked attribute values in catalogue title
"""
enum AttributePositionInTitleEnum {
  afterKeyword
  beforeKeyword
  begin
  end
  replaceKeyword
}

type AttributesGroup {
  attributes: [Attribute!]!
  id: ID!
  name: [LanguageType!]!
  nameString: String!
}

type AttributesGroupPayloadType {
  group: AttributesGroup
  message: String!
  success: Boolean!
}

type AttributeVariant {
  id: ID!
  nameString: String!
}

"""Attribute variant enum"""
enum AttributeVariantEnum {
  multipleSelect
  number
  select
  string
}

type CatalogueData {
  catalogueTitle: String!
  products: PaginatedProductsResponse!
  rubric: Rubric!
}

type CatalogueSearchResult {
  products: [Product!]!
  rubrics: [Rubric!]!
}

type City {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
  slug: String!
}

type CityCounter {
  counter: Int
  key: String!
}

input CityLangInput {
  key: String!
  value: [String!]!
}

type Config {
  """Accepted formats for asset config."""
  acceptedFormats: [String!]!
  cities: [ConfigCity!]!
  description: String!
  id: ID!

  """Set to true if config is able to hold multiple values."""
  multi: Boolean!
  nameString: String!
  order: Float!
  slug: String!

  """Returns current value of current city."""
  value: [String!]!
  variant: ConfigVariantEnum!
}

type ConfigCity {
  city: City!
  key: String!
  translations: [ConfigLanguage!]!
}

input ConfigCityInput {
  key: String!
  translations: [CityLangInput!]!
}

type ConfigLanguage {
  key: String!
  value: [String!]!
}

type ConfigPayloadType {
  configs: [Config!]!
  message: String!
  success: Boolean!
}

"""Config variant enum"""
enum ConfigVariantEnum {
  asset
  email
  number
  string
  tel
}

type Country {
  cities: [City!]!
  currency: String!
  id: ID!
  nameString: String!
}

type CountryPayloadType {
  country: Country
  message: String!
  success: Boolean!
}

input CreateAttributesGroupInput {
  name: [LangInput!]!
}

input CreateCountryInput {
  currency: String!
  nameString: String!
}

input CreateCurrencyInput {
  nameString: String!
}

input CreateLanguageInput {
  key: String!
  name: String!
  nativeName: String!
}

input CreateMetricInput {
  name: [LangInput!]!
}

input CreateOptionsGroupInput {
  name: [LangInput!]!
}

input CreateProductConnectionInput {
  attributeId: ID!
  attributesGroupId: ID!
  productId: ID!
}

input CreateProductInput {
  assets: [Upload!]!
  attributesGroups: [ProductAttributesGroupInput!]!
  cardName: [LangInput!]!
  description: [LangInput!]!
  name: [LangInput!]!
  price: Int!
  rubrics: [ID!]!
}

input CreateRoleInput {
  description: String!
  isStuff: Boolean!
  name: [LangInput!]!
}

input CreateRubricInput {
  catalogueTitle: RubricCatalogueTitleInput!
  name: [LangInput!]!
  parent: ID
  variant: ID!
}

input CreateRubricVariantInput {
  name: [LangInput!]!
}

input CreateUserInput {
  email: String!
  lastName: String
  name: String!
  phone: String!
  role: ID!
  secondName: String
}

type Currency {
  id: ID!
  nameString: String!
}

type CurrencyPayloadType {
  currency: Currency
  message: String!
  success: Boolean!
}

input DeleteAttributeFromGroupInput {
  attributeId: ID!
  groupId: ID!
}

input DeleteAttributesGroupFromRubricInput {
  attributesGroupId: ID!
  rubricId: ID!
}

input DeleteCityFromCountryInput {
  cityId: ID!
  countryId: ID!
}

input DeleteOptionFromGroupInput {
  groupId: ID!
  optionId: ID!
}

input DeleteProductFromConnectionInput {
  addProductId: ID!
  connectionId: ID!
  productId: ID!
}

input DeleteProductFromRubricInput {
  productId: ID!
  rubricId: ID!
}

"""List of gender enums"""
enum GenderEnum {
  he
  it
  she
}

type GenderOption {
  id: String!
  nameString: String!
}

type ISOLanguage {
  id: String!
  nameString: String!
  nativeName: String!
}

input LangInput {
  key: String!
  value: String!
}

type Language {
  id: ID!
  isDefault: Boolean!
  key: String!
  name: String!
  nativeName: String!
}

type LanguagePayloadType {
  language: Language
  message: String!
  success: Boolean!
}

type LanguageType {
  key: String!
  value: String!
}

type Message {
  id: ID!
  key: String!
  message: [LanguageType!]!
}

type Metric {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
}

type MetricPayloadType {
  message: String!
  metric: Metric
  success: Boolean!
}

type Mutation {
  addAttributesGroupToRubric(input: AddAttributesGroupToRubricInput!): RubricPayloadType!
  addAttributeToGroup(input: AddAttributeToGroupInput!): AttributesGroupPayloadType!
  addCityToCountry(input: AddCityToCountryInput!): CountryPayloadType!
  addOptionToGroup(input: AddOptionToGroupInput!): OptionsGroupPayloadType!
  addProductToConnection(input: AddProductToConnectionInput!): ProductPayloadType!
  addProductToRubric(input: AddProductToRubricInput!): RubricPayloadType!
  createAttributesGroup(input: CreateAttributesGroupInput!): AttributesGroupPayloadType!
  createCountry(input: CreateCountryInput!): CountryPayloadType!
  createCurrency(input: CreateCurrencyInput!): CurrencyPayloadType!
  createLanguage(input: CreateLanguageInput!): LanguagePayloadType!
  createMetric(input: CreateMetricInput!): MetricPayloadType!
  createOptionsGroup(input: CreateOptionsGroupInput!): OptionsGroupPayloadType!
  createProduct(input: CreateProductInput!): ProductPayloadType!
  createProductConnection(input: CreateProductConnectionInput!): ProductPayloadType!
  createRole(input: CreateRoleInput!): RolePayloadType!
  createRubric(input: CreateRubricInput!): RubricPayloadType!
  createRubricVariant(input: CreateRubricVariantInput!): RubricVariantPayloadType!
  createUser(input: CreateUserInput!): UserPayloadType!
  deleteAttributeFromGroup(input: DeleteAttributeFromGroupInput!): AttributesGroupPayloadType!
  deleteAttributesGroup(id: ID!): AttributesGroupPayloadType!
  deleteAttributesGroupFromRubric(input: DeleteAttributesGroupFromRubricInput!): RubricPayloadType!
  deleteCityFromCountry(input: DeleteCityFromCountryInput!): CountryPayloadType!
  deleteCountry(id: ID!): CountryPayloadType!
  deleteCurrency(id: ID!): CurrencyPayloadType!
  deleteLanguage(id: ID!): LanguagePayloadType!
  deleteMetric(id: ID!): MetricPayloadType!
  deleteOptionFromGroup(input: DeleteOptionFromGroupInput!): OptionsGroupPayloadType!
  deleteOptionsGroup(id: ID!): OptionsGroupPayloadType!
  deleteProduct(id: ID!): ProductPayloadType!
  deleteProductFromConnection(input: DeleteProductFromConnectionInput!): ProductPayloadType!
  deleteProductFromRubric(input: DeleteProductFromRubricInput!): RubricPayloadType!
  deleteRole(id: ID!): RolePayloadType!
  deleteRubric(id: ID!): RubricPayloadType!
  deleteRubricVariant(id: ID!): RubricVariantPayloadType!
  deleteUser(id: ID!): UserPayloadType!
  setLanguageAsDefault(id: ID!): LanguagePayloadType!
  setRoleAllowedNavItem(input: SetRoleAllowedNavItemInput!): RolePayloadType!
  setRoleOperationCustomFilter(input: SetRoleOperationCustomFilterInput!): RolePayloadType!
  setRoleOperationPermission(input: SetRoleOperationPermissionInput!): RolePayloadType!
  setRoleRuleRestrictedField(input: SetRoleRuleRestrictedFieldInput!): RolePayloadType!
  signIn(input: SignInInput!): UserPayloadType!
  signOut: UserPayloadType!
  signUp(input: SignUpInput!): UserPayloadType!
  updateAssetConfig(input: UpdateAssetConfigInput!): ConfigPayloadType!
  updateAttributeInGroup(input: UpdateAttributeInGroupInput!): AttributesGroupPayloadType!
  updateAttributesGroup(input: UpdateAttributesGroupInput!): AttributesGroupPayloadType!
  updateAttributesGroupInRubric(input: UpdateAttributesGroupInRubricInput!): RubricPayloadType!
  updateCityInCountry(input: UpdateCityInCountryInput!): CountryPayloadType!
  updateConfig(input: UpdateConfigInput!): ConfigPayloadType!
  updateConfigs(input: [UpdateConfigInput!]!): ConfigPayloadType!
  updateCountry(input: UpdateCountryInput!): CountryPayloadType!
  updateCurrency(input: UpdateCurrencyInput!): CurrencyPayloadType!
  updateLanguage(input: UpdateLanguageInput!): LanguagePayloadType!
  updateMetric(input: UpdateMetricInput!): MetricPayloadType!
  updateMyPassword(input: UpdateMyPasswordInput!): UserPayloadType!
  updateMyProfile(input: UpdateMyProfileInput!): UserPayloadType!
  updateOptionInGroup(input: UpdateOptionInGroupInput!): OptionsGroupPayloadType!
  updateOptionsGroup(input: UpdateOptionsGroupInput!): OptionsGroupPayloadType!
  updateProduct(input: UpdateProductInput!): ProductPayloadType!
  updateRole(input: UpdateRoleInput!): RolePayloadType!
  updateRubric(input: UpdateRubricInput!): RubricPayloadType!
  updateRubricVariant(input: UpdateRubricVariantInput!): RubricVariantPayloadType!
  updateUser(input: UpdateUserInput!): UserPayloadType!
}

type NavItem {
  children: [NavItem!]
  icon: String
  id: String!
  name: [LanguageType!]!
  nameString: String!
  navGroup: String!
  order: Int!
  parent: NavItem
  path: String
}

type Option {
  color: String
  filterNameString: String!
  gender: GenderEnum
  id: ID!
  name: [LanguageType!]!
  nameString: String!
  priorities: [OptionCityCounter!]!
  slug: String!
  variants: [OptionVariant!]
  views: [OptionCityCounter!]!
}

type OptionCityCounter {
  attributeId: String!
  counter: Int
  key: String!
  rubricId: String!
}

type OptionsGroup {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
  options: [Option!]!
}

type OptionsGroupPayloadType {
  group: OptionsGroup
  message: String!
  success: Boolean!
}

type OptionVariant {
  key: GenderEnum!
  value: [LanguageType!]!
}

input OptionVariantInput {
  key: GenderEnum!
  value: [LangInput!]!
}

type PaginatedProductsResponse {
  activeProductsCount: Int
  docs: [Product!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

type PaginatedUsersResponse {
  docs: [User!]!
  hasNextPage: Int!
  hasPrevPage: Int!
  limit: Int!
  nextPage: Int
  page: Int
  pagingCounter: Int!
  prevPage: Int
  totalDocs: Int!
  totalPages: Int!
}

"""Pagination sortDir enum"""
enum PaginateSortDirectionEnum {
  asc
  desc
}

type Product {
  active: Boolean!
  assets: [AssetType!]!
  attributesGroups: [ProductAttributesGroup!]!
  cardName: [LanguageType!]!
  cardNameString: String!
  connections: [ProductConnection!]!
  createdAt: Timestamp!
  description: [LanguageType!]!
  descriptionString: String!
  id: ID!
  itemId: Int!
  mainImage: String!
  name: [LanguageType!]!
  nameString: String!
  price: Int!
  priorities: [CityCounter!]!
  rubrics: [ID!]!
  slug: String!
  updatedAt: Timestamp!
  views: [CityCounter!]!
}

type ProductAttribute {
  """Attribute reference via attribute slug field"""
  key: String!
  node: Attribute!
  showInCard: Boolean!
  value: [String!]!
}

input ProductAttributeInput {
  """Attribute reference via attribute slug field"""
  key: String!
  node: ID!
  showInCard: Boolean!
  value: [String!]!
}

type ProductAttributesGroup {
  attributes: [ProductAttribute!]!
  node: AttributesGroup!
  showInCard: Boolean!
}

input ProductAttributesGroupInput {
  attributes: [ProductAttributeInput!]!
  node: ID!
  showInCard: Boolean!
}

type ProductConnection {
  attribute: Attribute!
  attributeId: String!
  attributesGroupId: String!
  id: ID!

  """Attribute reference via attribute slug field"""
  key: String!
  products: [ProductConnectionItem!]!
  productsIds: [String!]!
}

type ProductConnectionItem {
  node: Product!

  """
  Returns first value only because this attribute has to be Select variant
  """
  value: String!
}

input ProductPaginateInput {
  countActiveProducts: Boolean
  limit: Int = 100
  noRubrics: Boolean
  notInRubric: ID
  page: Int = 1
  rubric: ID
  search: String
  sortBy: ProductSortByEnum = priority
  sortDir: PaginateSortDirectionEnum = desc
}

type ProductPayloadType {
  message: String!
  product: Product
  success: Boolean!
}

type ProductsCounters {
  activeProductsCount: Int!
  totalProductsCount: Int!
}

input ProductsCountersInput {
  noRubrics: Boolean
  notInRubric: ID
  rubric: ID
}

"""Product pagination sortBy enum"""
enum ProductSortByEnum {
  createdAt
  price
  priority
}

type Query {
  getAllAppNavItems: [NavItem!]!
  getAllAttributesGroups(
    """list of excluded groups id's"""
    exclude: [ID!] = []
  ): [AttributesGroup!]!
  getAllCities: [City!]!
  getAllConfigs: [Config!]!
  getAllCountries: [Country!]!
  getAllCurrencies: [Currency!]!
  getAllLanguages: [Language!]
  getAllMetrics: [Metric!]
  getAllOptionsGroups: [OptionsGroup!]!
  getAllProducts(input: ProductPaginateInput = {}): PaginatedProductsResponse!
  getAllRoles: [Role!]!
  getAllRubricVariants: [RubricVariant!]
  getAllUsers(input: UserPaginateInput!): PaginatedUsersResponse!
  getAttribute(id: ID!): Attribute
  getAttributePositioningOptions: [AttributePositioningOption!]!
  getAttributesGroup(id: ID!): AttributesGroup
  getAttributeVariants: [AttributeVariant!]
  getCatalogueData(catalogueFilter: [String!]!, productsInput: ProductPaginateInput): CatalogueData
  getCatalogueSearchResult(search: String!): CatalogueSearchResult!
  getCatalogueSearchTopItems: CatalogueSearchResult!
  getCity(id: ID!): City!
  getCityBySlug(slug: String!): City!
  getClientLanguage: String!
  getConfigBySlug(slug: String!): Config!
  getConfigValueBySlug(slug: String!): [String!]!
  getCountry(id: ID!): Country!
  getCurrency(id: ID!): Currency!
  getEntityFields(entity: String!): [String!]!
  getFeaturesAst(selectedRubrics: [ID!]!): [AttributesGroup!]!
  getGenderOptions: [GenderOption!]!
  getISOLanguagesList: [ISOLanguage!]!
  getLanguage(id: ID!): Language
  getMessage(key: String!): Message!
  getMessagesByKeys(keys: [String!]!): [Message!]!
  getMetric(id: ID!): Metric
  getOption(id: ID!): Option
  getOptionsGroup(id: ID!): OptionsGroup
  getProduct(id: ID!): Product!
  getProductBySlug(slug: String!): Product!
  getProductCard(slug: String!): Product!
  getProductsCounters(input: ProductsCountersInput = {}): ProductsCounters!
  getRole(id: ID!): Role!
  getRubric(id: ID!): Rubric!
  getRubricBySlug(slug: String!): Rubric!
  getRubricsTree(excluded: [ID!] = []): [Rubric!]!
  getRubricVariant(id: ID!): RubricVariant
  getSessionCurrency: String!
  getSessionRole: Role!
  getUser(id: ID!): User
  getValidationMessages: [Message!]!
  me: User
}

type Role {
  allowedAppNavigation: [ID!]!
  appNavigation: [NavItem!]!
  description: String!
  id: String!
  isStuff: Boolean!
  name: [LanguageType!]!
  nameString: String!
  rules: [RoleRule!]!
  slug: String!
}

type RolePayloadType {
  message: String!
  role: Role
  success: Boolean!
}

type RoleRule {
  entity: String!
  id: ID!
  nameString: String!
  operations: [RoleRuleOperation!]!
  restrictedFields: [String!]!
  roleId: ID!
}

type RoleRuleOperation {
  allow: Boolean!
  customFilter: String!
  id: ID!
  operationType: RoleRuleOperationTypeEnum!
  order: Int!
}

"""Role rule operation type enum"""
enum RoleRuleOperationTypeEnum {
  create
  delete
  read
  update
}

type Rubric {
  active: Boolean
  activeProductsCount: Int!
  attributesGroups: [RubricAttributesGroup!]!
  catalogueTitle: RubricCatalogueTitle!
  catalogueTitleString: RubricCatalogueTitleField!
  children(excluded: [ID!] = []): [Rubric!]!
  filterAttributes: [RubricFilterAttribute!]!
  id: ID!
  level: Int!
  name: [LanguageType!]!
  nameString: String!
  parent: Rubric
  priorities: [CityCounter!]!
  priority: Int
  products(input: RubricProductPaginateInput): PaginatedProductsResponse!
  slug: String!
  totalProductsCount: Int!
  variant: RubricVariant!
  views: [CityCounter!]!
}

type RubricAttributesGroup {
  id: ID!
  isOwner: Boolean!
  node: AttributesGroup!
  showInCatalogueFilter: [ID!]!
}

type RubricCatalogueTitle {
  defaultTitle: [LanguageType!]!
  gender: GenderEnum!
  keyword: [LanguageType!]!
  prefix: [LanguageType!]
}

type RubricCatalogueTitleField {
  defaultTitle: String!
  gender: GenderEnum!
  keyword: String!
  prefix: String
}

input RubricCatalogueTitleInput {
  defaultTitle: [LangInput!]!
  gender: GenderEnum!
  keyword: [LangInput!]!
  prefix: [LangInput!]
}

type RubricFilterAttribute {
  id: ID!
  node: Attribute!
  options: [RubricFilterAttributeOption!]!
}

type RubricFilterAttributeOption {
  color: String
  counter: Int!
  filterNameString: String!
  gender: GenderEnum
  id: ID!
  name: [LanguageType!]!
  nameString: String!
  priorities: [OptionCityCounter!]!
  slug: String!
  variants: [OptionVariant!]
  views: [OptionCityCounter!]!
}

type RubricPayloadType {
  message: String!
  rubric: Rubric
  success: Boolean!
}

input RubricProductAttributesFilterInput {
  key: String!
  value: [String!]!
}

input RubricProductPaginateInput {
  active: Boolean
  attributes: [RubricProductAttributesFilterInput!]
  limit: Int = 100
  notInRubric: ID
  page: Int = 1
  search: String
  sortBy: ProductSortByEnum = createdAt
  sortDir: PaginateSortDirectionEnum = desc
}

type RubricVariant {
  id: ID!
  name: [LanguageType!]!
  nameString: String!
}

type RubricVariantPayloadType {
  message: String!
  success: Boolean!
  variant: RubricVariant
}

input SetRoleAllowedNavItemInput {
  navItemId: ID!
  roleId: ID!
}

input SetRoleOperationCustomFilterInput {
  customFilter: String!
  operationId: ID!
  roleId: ID!
}

input SetRoleOperationPermissionInput {
  allow: Boolean!
  operationId: ID!
  roleId: ID!
}

input SetRoleRuleRestrictedFieldInput {
  restrictedField: String!
  roleId: ID!
  ruleId: ID!
}

input SignInInput {
  email: String!
  password: String!
}

input SignUpInput {
  email: String!
  lastName: String
  name: String!
  password: String!
  phone: String
  secondName: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

input UpdateAssetConfigInput {
  id: ID!
  value: [Upload!]!
}

input UpdateAttributeInGroupInput {
  attributeId: ID!
  groupId: ID!
  metric: ID
  name: [LangInput!]!
  options: ID
  positioningInTitle: [AttributePositioningInTitleInput!]
  variant: AttributeVariantEnum!
}

input UpdateAttributesGroupInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateAttributesGroupInRubricInput {
  attributeId: ID!
  attributesGroupId: ID!
  rubricId: ID!
}

input UpdateCityInCountryInput {
  cityId: ID!
  countryId: ID!
  name: [LangInput!]!
  slug: String!
}

input UpdateConfigInput {
  cities: [ConfigCityInput!]!
  id: ID!
}

input UpdateCountryInput {
  currency: String!
  id: ID!
  nameString: String!
}

input UpdateCurrencyInput {
  id: ID!
  nameString: String!
}

input UpdateLanguageInput {
  id: ID!
  key: String!
  name: String!
  nativeName: String!
}

input UpdateMetricInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateMyPasswordInput {
  id: ID!
  newPassword: String!
  newPasswordB: String!
  oldPassword: String!
}

input UpdateMyProfileInput {
  email: String!
  id: ID!
  lastName: String
  name: String!
  phone: String!
  secondName: String
}

input UpdateOptionInGroupInput {
  color: String
  gender: GenderEnum
  groupId: ID!
  name: [LangInput!]!
  optionId: ID!
  variants: [OptionVariantInput!]
}

input UpdateOptionsGroupInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateProductInput {
  assets: [Upload!]!
  attributesGroups: [ProductAttributesGroupInput!]!
  cardName: [LangInput!]!
  description: [LangInput!]!
  id: ID!
  name: [LangInput!]!
  price: Int!
  rubrics: [ID!]!
}

input UpdateRoleInput {
  description: String!
  id: ID!
  isStuff: Boolean!
  name: [LangInput!]!
}

input UpdateRubricInput {
  catalogueTitle: RubricCatalogueTitleInput!
  id: ID!
  name: [LangInput!]!
  parent: ID
  variant: ID!
}

input UpdateRubricVariantInput {
  id: ID!
  name: [LangInput!]!
}

input UpdateUserInput {
  email: String!
  id: ID!
  lastName: String
  name: String!
  phone: String!
  role: ID!
  secondName: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  createdAt: Timestamp!
  email: String!
  fullName: String!
  id: ID!
  itemId: Int!
  lastName: String
  name: String!
  phone: String!
  role: Role!
  secondName: String
  shortName: String!
  updatedAt: Timestamp!
}

input UserPaginateInput {
  limit: Int = 100
  page: Int = 1
  search: String
  sortBy: UserSortByEnum = createdAt
  sortDir: PaginateSortDirectionEnum = desc
}

type UserPayloadType {
  message: String!
  success: Boolean!
  user: User
}

"""User pagination sortBy enum"""
enum UserSortByEnum {
  createdAt
  email
  lastName
  name
  phone
  role
  secondName
}
